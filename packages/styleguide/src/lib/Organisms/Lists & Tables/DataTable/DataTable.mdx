import { Canvas, Controls, Meta } from '@storybook/blocks';

import { Callout, ComponentHeader, LinkTo } from '~styleguide/blocks';

import * as DataTableStories from './DataTable.stories';

export const parameters = {
  title: 'DataTable',
  subtitle: `Compare large amounts of data and perform bulk actions on Table Rows.`,
  status: 'current',
  source: {
    repo: 'gamut',
    githubLink:
      'https://github.com/Codecademy/gamut/blob/main/packages/gamut/src/DataList/DataTable.tsx',
  },
};

<Meta of={DataTableStories} />

<ComponentHeader {...parameters} />

## Design principles

**Design principles**

- Recommended for bulk analysis across Rows
- Tables best support information that needs sorting, filtering, pagination, and querying
- Prioritize data and information that’s meant to be compared up front, then surface secondary information on external surfaces

**Use table affordances for best information design**

- Design and arrange table metrics to encourage finding, scanning, and comparing information

**Use cell-level interactions to activate specific data**

- Use Coachmarks, Tooltips, Modals, and Flyovers to augment information
- Use Anchors and Links to direct users to another surface

**Be careful about information overload**

- Determine what’s helpful to see en-masse, versus what info should be drilled down into
- Be mindful about the horizontal spacing between columns and headers
- Order metrics based on priority, and consider collapsing extraneous metrics on smaller sizes

## Usage

Use a `DataTable` to display a table of items that contain a lot of information. The top row of the table is the header, and each row below is a list item. Rows can be customized to show a loading state, scrollability, filtering, and sorting.

### Sample code

```tsx
const DataTown = () => {
  const [expandedRows, setExpandedRows] = useState([]);
  const columns = [
    { key: 'name', sortable: true, size: 'sm' },
    { key: 'ship', sortable: true, size: 'sm' },
  ];

  const queryData = useLocalQuery({
    idKey: 'name',
    rows: crew,
    columns,
  });

  return (
    <DataTable
      id="example"
      columns={columns}
      expandedRows={expandedRows}
      onRowExpand={setExpandedRows}
      renderExpanded={({ name }) => <>{name}: This is pretty cool</>}
      {...queryData}
    />
  );
};
```

## Configurations

### Sorting and filtering

Each column takes a `sortable` and `filters` prop - this is will determine if the column should be sortable and which filters should appear in the dropdown menu of the column.

<Canvas of={DataTableStories.FullDataTable} />

### Empty state

When a DataTable has no data to display, it should show an empty state message.

<Canvas of={DataTableStories.EmptyState} />

This empty state message is customizable through the `emptyState` prop.

<Canvas of={DataTableStories.EmptyStateCustom} />

For optimal accessibility, the empty message should match the pattern below. This pattern also includes the necessary `sticky` styles if you'd like your custom message to stay in one place while the user scrolls.

```tsx
// main container
<Box as="tbody" height="100%" width="100%">
  // all children of `tbody`should be `tr`
  <FlexBox
    as="tr"
    height="inherit"
    position="absolute"
    width="inherit"
    zIndex={1}
  >
    // each child of `tr` should be `th`
    <FlexBox
      as="th"
      center
      column
      // the px value should be 1/2 the width of the container to center correctly
      left="calc(50% - 115px)"
      p={16}
      position="sticky"
      // the px value should be 1/2 the height of the container to center correctly
      top="calc(50% - 115px)"
      width="fit-content"
    >
      <BlueprintWhite aria-hidden width="200px" />
      <Text fontFamily="monospace" mt={16}>
        Nothing to see here!
      </Text>
    </FlexBox>
  </FlexBox>
</Box>
```

### Loading rows

Replaces content of current rows with <LinkTo id="Atoms/Loaders/Shimmer">Shimmer</LinkTo>.

<Canvas of={DataTableStories.LoadingRows} />

### Scrollable indicators

You can set the `shadow` prop to `true` to add a shadow to the DataTable when it is scrollable.

<Canvas of={DataTableStories.Scrollable} />

## Background colors

DataTable's background is linked to the `current-background` token. You can change the color scheme of a DataTable by wrapping it in a `<Background />` component from `@codecademy/gamut-styles`.

When you wrap a DataTable in `Background`, the component will also automatically adjust its colors to ensure proper contrast and accessibility. For example, using a dark background like `bg="black"` will switch the DataTable to dark mode, making text and UI elements light-colored for better contrast. You can find more information about the `Background` component in the <LinkTo id="Foundations/ColorMode">ColorMode documentation</LinkTo>.

### Usage

```tsx
import { Background } from '@codecademy/gamut-styles';
import { DataTable } from '@codecademy/gamut';

const MyDarkDataTable = () => {
  return (
    <Background bg="black" p={8}>
      <DataTable id="dark-table" idKey="id" rows={data} columns={columns} />
    </Background>
  );
};
```

<Canvas of={DataTableStories.BackgroundColors} />

## Container Query Control

DataTable inherits container query functionality from the underlying List component. By default, DataTable uses CSS container queries to determine responsive behavior based on the container width rather than viewport width. This ensures optimal display when DataTable is placed in constrained layouts.

### When to use `disableContainerQuery={true}`

- **DataTable in narrow containers**: When your DataTable is always rendered in a constrained space (like a 300px sidebar)
- **Dense data tables**: When you have many columns that need consistent behavior regardless of container width
- **Custom responsive management**: When implementing your own responsive logic and want to avoid conflicts
- **Performance considerations**: In rare cases where container query support may impact performance

### Example usage

```tsx
// Disable container queries for a DataTable in a narrow container
<div style={{ width: '280px' }}>
  <DataTable
    disableContainerQuery
    id="sidebar-table"
    idKey="id"
    rows={data}
    columns={columns}
    spacing="condensed"
  />
</div>

// Use default container query behavior (recommended for most cases)
<DataTable
  id="main-table"
  idKey="id"
  rows={data}
  columns={columns}
  spacing="condensed"
/>
```

The example below demonstrates the difference between default container query behavior and disabled container queries:

<Canvas of={DataTableStories.DisableContainerQuery} />

<Callout text="In most cases, you should use the default container query behavior as it provides better responsive design. Only disable container queries when you have specific layout requirements that conflict with the default behavior." />

## Playground

<Canvas sourceState="shown" of={DataTableStories.Default} />

<Controls />
