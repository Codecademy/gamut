import { Canvas, Controls, Meta } from '@storybook/blocks';

import { ComponentHeader, LinkTo } from '~styleguide/blocks';

import * as BarChartStories from './BarChart.stories';

export const parameters = {
  subtitle: `A horizontal bar chart for visualizing comparative data`,
  design: {
    type: 'figma',
    url: 'https://www.figma.com/design/ReGfRNillGABAj5SlITalN/%F0%9F%93%90-Gamut?node-id=55123-4176',
  },
  status: 'current',
  source: {
    repo: 'gamut',
    githubLink:
      'https://github.com/Codecademy/gamut/blob/main/packages/gamut/src/BarChart',
  },
};

<Meta of={BarChartStories} />;

<ComponentHeader {...parameters} />

## Usage

Use BarChart to display comparative data across categories, such as skills progress, XP earned, or any quantitative metrics that benefit from visual comparison.

### Best practices:

- Use consistent units across all bars in a chart
- Limit the number of bars to maintain readability (5-10 is optimal)
- Consider using the stacked variant to show progress toward a goal
- Sort bars by value (descending) when ranking is important

When NOT to use

- For showing trends over time - use a line chart instead
- For showing parts of a whole - use a pie or donut chart
- For very small datasets (1-2 items) - consider using ProgressBar

## Variants

### Simple (Non-stacked)

Use the simple variant when showing single values per category. Only `seriesOneValue` is provided.

<Canvas of={BarChartStories.Default} />

### Stacked

Use the stacked variant when showing progress within a total. Provide both `seriesOneValue` (progress) and `seriesTwoValue` (total).

<Canvas of={BarChartStories.Stacked} />

### With Icons

Add icons to labels for better visual identification of categories.

<Canvas of={BarChartStories.WithIcons} />

### Animated

Enable entrance animations for a more engaging experience.

<Canvas of={BarChartStories.Animated} />

### Interactive

Rows can be made interactive with `onClick` handlers or `href` links.

<Canvas of={BarChartStories.Interactive} />

### Sorting

BarChart includes an optional sorting dropdown in the title area. The dropdown only renders when the `sortFns` prop is provided. You can control which sort options appear by including string literals or custom sort functions in the array.

**String Literals:**

- `'alphabetically'` - Adds both "Label (A-Z)" and "Label (Z-A)" options
- `'numerically'` - Adds both "Value (Low-High)" and "Value (High-Low)" options
- `'none'` - Adds "None" option (preserves original order)

**Custom Sort Functions:**
You can also provide custom sort functions as objects with:

- `label`: The text displayed in the dropdown
- `value`: A unique identifier for the sort option
- `sortFn`: A function that takes an array of bars and returns a sorted array

**Type Definition:**

```typescript
type CustomSortOption<TBar extends BarProps = BarProps> = {
  label: string;
  value: string;
  sortFn: (bars: TBar[]) => TBar[];
};

// sortFns prop accepts:
sortFns?: ('alphabetically' | 'numerically' | 'none' | CustomSortOption<TBar>)[]
```

**Automatic Type Inference:**
TypeScript automatically infers the bar type from your `barValues` prop. This means custom properties (like `dateAdded`, `category`, etc.) are automatically typed in your sort functions - no type assertions needed!

```typescript
const barsWithDates = [
  { yLabel: 'Python', seriesOneValue: 1500, dateAdded: new Date('2023-01-15') },
  {
    yLabel: 'JavaScript',
    seriesOneValue: 2000,
    dateAdded: new Date('2023-03-20'),
  },
  // ...
];

<BarChart
  barValues={barsWithDates}
  sortFns={[
    {
      label: 'Recently Added',
      value: 'recent',
      sortFn: (bars) => {
        // TypeScript automatically knows bars have dateAdded property!
        return [...bars].sort((a, b) => {
          const aDate = a.dateAdded as Date | undefined;
          const bDate = b.dateAdded as Date | undefined;
          if (!aDate || !bDate) return 0;
          return bDate.getTime() - aDate.getTime();
        });
      },
    },
  ]}
/>;
```

**Note:** Since `BarProps` uses `Record<string, unknown>` for extensibility, custom properties are typed as `unknown` by default. You may need a simple type assertion (`as Date | undefined`) when accessing them, but the property names are fully type-checked.

<Canvas of={BarChartStories.WithSorting} />

**Example with Custom Sort Functions:**

Custom sort functions can access additional properties on `BarProps` for domain-specific sorting, such as sorting by dates or categories.

<Canvas of={BarChartStories.WithCustomSorting} />

When a bar has an `onClick` handler or `href` link, an `aria-label` is automatically generated from the bar's data and applied to the button or link element. The label summarizes the bar's values (e.g., "100 XP in Python" for a simple bar, or "200 XP gained - now at 1500 XP in Python" for a stacked bar).

This ensures that screen reader users receive a clear, data-driven description when interacting with bars, without requiring manual `aria-label` props.

<Canvas of={BarChartStories.WithLinks} />

## Accessibility considerations

### Chart and row labeling

**Chart-level labeling:**

- Always provide either `title` or `aria-labelledby` to describe the chart (see Title and description section below for details)
- The chart is wrapped in a semantic `<figure>` element for proper structure

**Row-level labeling:**

- For non-interactive bars: A hidden text element (visible only to screen readers) is automatically added as the first child of each list item, summarizing the bar's values (e.g., "100 XP in Python")
- For interactive bars (with `onClick` or `href`): An `aria-label` is automatically generated from the bar's data and applied to the button or link element, ensuring proper screen reader announcements
- All accessibility labels are automatically generated from the bar's data - no manual `aria-label` props are required

## UX writing

- Keep y-axis labels concise (1-3 words)
- Use consistent unit labels (e.g., "XP", "hours", "points")
- Consider locale-aware number formatting for international audiences

### Title and description

The BarChart component uses semantic HTML to provide context and accessibility. The chart is wrapped in a [`<figure>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/figure) element, and the description is displayed in a [`<figcaption>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/figcaption) element. This semantic structure helps screen readers and other assistive technologies understand the relationship between the chart and its description. **Visual title + description is the greatly preferred pattern** for accessibility and user experience.

**Preferred pattern: Visual title + description**

Provide both `title` and `description` props to make the chart's purpose and key takeaways clear to all users:

- `title`: A heading that identifies the chart. Can be a string or an object with `{ as?: 'h1' | 'h2' | 'h3' | 'h4' | 'h5' | 'h6', title: string, variant?: Text['variant'] }` to specify the heading level and optionally override the default styling with a <LinkTo id="Typography/Text">Text variant</LinkTo>.
- `description`: A summary of the information or the overall takeaway displayed in the `<figcaption>` element.

<Canvas of={BarChartStories.WithVisualTitleAndDescription} />

**Alternative patterns:**
`hideTitle` and `hideDescription` will keep the screenreader text but hide the visual descriptions.

<Canvas of={BarChartStories.WithHiddenTitleAndDescription} />

- **External title with visual description**: Use `aria-labelledby` for the title but show the description visually when the title exists elsewhere but you want to display the description.

<Canvas of={BarChartStories.WithExternalTitle} />

**Best practices:**

- Always provide a `description` prop - it's required and should summarize the chart's key information
- Use semantic heading levels for titles (h1-h6) to maintain proper document structure
- When using `aria-labelledby`, ensure the referenced element exists and is properly labeled

## Playground

<Canvas sourceState="shown" of={BarChartStories.Default} />

<Controls />
