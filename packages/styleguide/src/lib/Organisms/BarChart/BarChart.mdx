import { Canvas, Controls, Meta } from '@storybook/blocks';

import {
  Callout,
  ComponentHeader,
  ImageWrapper,
  LinkTo,
} from '~styleguide/blocks';

import * as BarChartStories from './BarChart.stories';

export const parameters = {
  title: 'BarChart',
  subtitle: `A horizontal bar chart for visualizing comparative data`,
  design: {
    type: 'figma',
    url: 'https://www.figma.com/design/ReGfRNillGABAj5SlITalN/%F0%9F%93%90-Gamut?node-id=55123-4176',
  },
  status: 'updating',
  source: {
    repo: 'gamut',
    githubLink:
      'https://github.com/Codecademy/gamut/blob/main/packages/gamut/src/BarChart',
  },
};

<Meta of={BarChartStories} />

<ComponentHeader {...parameters} />

## Usage

Use BarChart to display comparative data across categories, such as skills progress, XP earned, or any quantitative metrics that benefit from visual comparison.

### Best practices:

- Use consistent units across all bars in a chart
- Limit the number of bars to maintain readability (5-10 is optimal)
- Consider using the stacked variant to show progress toward a goal
- Sort bars by value (descending) when ranking is important
- Ensure bar colors maintain at least a 3:1 contrast ratio with the background

### When NOT to use:

- **Progress tracking** â€“ for displaying the completion status of a task, use the <LinkTo id="Atoms/ProgressBar">ProgressBar</LinkTo> component.

## Anatomy

<ImageWrapper
  src="./organisms/barchart.png"
  alt="The anatomy of the BarChart component, detailed below."
/>

1. **Bar row**

- Represents a single category and its values.

2. **Category icon** (optional)

- Use to clarify or reinforce the category name.

3. **Category label**

- Displays gridlines and labels to indicate the scale of the data values.
- The number of dividers, as well as the minimum and maximum values on the value axis, are adjustable.
- The minimum value should always be 0.

4. **Series one value**

- Displays the numerical value of the series one bar for clarity and precise data representation.

5. **Series two value** (optional)

- Displays the numerical value of the series two bar for clarity and precise data representation.
- Include a second series value by using the stacked property. Stacked bar charts compare parts of a whole and are best suited for displaying discrete data segmented into meaningful categories.

6. ** Series one bar**

- A visual representation of the first value for the associated category.
- By default, the first series bars use the text color, however, it can be overridden to any color.
- Bars include a required border that uses white or navy, chosen automatically to ensure the highest contrast with the bar color.

8. **Series two bar** _(bars with zero value)_

- A visual representation of the second value for the associated category.
- By default, the second series bars use the primary color, however, it can be overridden to any color.
- Bars include a required border that uses white or navy, chosen automatically to ensure the highest contrast with the bar color.
- Bars include a required border that uses white or navy, chosen automatically to ensure the highest contrast with the bar color.

## Variants

### Simple (Non-stacked)

Use the simple variant when showing single values per category. Only `seriesOneValue` is provided.

<Canvas of={BarChartStories.Default} />

### Stacked

Use the stacked variant when showing progress within a total. Provide both `seriesOneValue` (progress) and `seriesTwoValue` (total).

<Canvas of={BarChartStories.Stacked} />

### With Icons

Add icons to labels for better visual identification of categories.

<Canvas of={BarChartStories.WithIcons} />

### Animated

Enable entrance animations for a more engaging experience.

<Canvas of={BarChartStories.Animated} />

### Interactive

Rows can be made interactive with `onClick` handlers or `href` links.

<Canvas of={BarChartStories.Interactive} />

### Sorting

BarChart includes an optional sorting dropdown in the title area. The dropdown only renders when the `sortFns` prop is provided. You can control which sort options appear by including string literals or custom sort functions in the array.

**String Literals:**

- `'alphabetically'` - Adds both "Label (A-Z)" and "Label (Z-A)" options
- `'numerically'` - Adds both "Value (Low-High)" and "Value (High-Low)" options
- `'none'` - Adds "None" option (preserves original order)

**Custom Sort Functions:**
You can also provide custom sort functions as objects with:

- `label`: The text displayed in the dropdown
- `value`: A unique identifier for the sort option
- `sortFn`: A function that takes an array of bars and returns a sorted array

**Type Definition:**

```typescript
type CustomSortOption<TBar extends BarProps = BarProps> = {
  label: string;
  value: string;
  sortFn: (bars: TBar[]) => TBar[];
};

// sortFns prop accepts:
sortFns?: ('alphabetically' | 'numerically' | 'none' | CustomSortOption<TBar>)[]
```

**Automatic Type Inference:**
TypeScript automatically infers the bar type from your `barValues` prop. This means custom properties (like `dateAdded`, `category`, etc.) are automatically typed in your sort functions - no type assertions needed!

```typescript
const barsWithDates = [
  { yLabel: 'Python', seriesOneValue: 1500, dateAdded: new Date('2023-01-15') },
  {
    yLabel: 'JavaScript',
    seriesOneValue: 2000,
    dateAdded: new Date('2023-03-20'),
  },
  // ...
];

<BarChart
  barValues={barsWithDates}
  sortFns={[
    {
      label: 'Recently Added',
      value: 'recent',
      sortFn: (bars) => {
        // TypeScript automatically knows bars have dateAdded property!
        return [...bars].sort((a, b) => {
          const aDate = a.dateAdded as Date | undefined;
          const bDate = b.dateAdded as Date | undefined;
          if (!aDate || !bDate) return 0;
          return bDate.getTime() - aDate.getTime();
        });
      },
    },
  ]}
/>;
```

**Note:** Since `BarProps` uses `Record<string, unknown>` for extensibility, custom properties are typed as `unknown` by default. You may need a simple type assertion (`as Date | undefined`) when accessing them, but the property names are fully type-checked.

<Canvas of={BarChartStories.WithSorting} />

**Example with Custom Sort Functions:**

Custom sort functions can access additional properties on `BarProps` for domain-specific sorting, such as sorting by dates or categories.

<Canvas of={BarChartStories.WithCustomSorting} />

When a bar has an `onClick` handler or `href` link, an `aria-label` is automatically generated from the bar's data and applied to the button or link element. The label summarizes the bar's values (e.g., "100 XP in Python" for a simple bar, or "200 XP gained - now at 1500 XP in Python" for a stacked bar).

This ensures that screen reader users receive a clear, data-driven description when interacting with bars, without requiring manual `aria-label` props.

<Canvas of={BarChartStories.WithLinks} />

## Interactive states

BarChart supports both interactive and static bar rows, each with distinct visual states.

### Static bars

When bars have neither `onClick` handlers nor `href` links, they are rendered as static, non-interactive elements.

<Canvas of={BarChartStories.Default} />

### Interactive bars

When bars have `onClick` handlers or `href` links, they become interactive. Interactive bars are rendered as buttons or anchor elements, providing full keyboard accessibility and proper semantic HTML.

<Canvas of={BarChartStories.Interactive} />

## Color modes

BarChart automatically adapts to both light and dark color modes, ensuring proper contrast and readability in all themes. The component uses semantic color tokens that adjust based on the current color mode. The `styleConfig` prop should be provided by semantic color tokens to ensure the `BarChart` is accessible in all color modes.

## Custom styling

BarChart supports custom color styling through the `styleConfig` prop, allowing you to customize the appearance of chart elements to match your design needs.

### Style configuration options

The `styleConfig` prop accepts an object with the following optional properties:

- **`textColor`**: Color for text labels (y-axis labels). Defaults to `'text'`
- **`foregroundBarColor`**: Color for the foreground/progress bar (used in stacked charts for `seriesOneValue`). Defaults to `'feedback-warning'`
- **`backgroundBarColor`**: Color for the background/total bar (used for `seriesTwoValue` in stacked charts, or `seriesOneValue` in simple charts). Defaults to `'background-primary'`
- **`seriesOneLabel`**: Color for the series one value label (first right label when stacked, or displayValue when not stacked). Defaults to `'text-secondary'`
- **`seriesTwoLabel`**: Color for the series two value label (displayValue when stacked). Defaults to `'primary'`

All color values should be valid color tokens from the Gamut design system. When customizing colors, ensure they maintain at least a 3:1 contrast ratio with the background for accessibility.

### Default values

If `styleConfig` is not provided, BarChart uses these default colors:

```typescript
{
  textColor: 'text',
  foregroundBarColor: 'feedback-warning',
  backgroundBarColor: 'background-primary',
  seriesOneLabel: 'text-secondary',
  seriesTwoLabel: 'primary',
}
```

### Example

<Canvas of={BarChartStories.CustomStyles} />

## Custom scale

BarChart allows you to customize the x-axis scale interval using the `xScale` prop, which controls the spacing and granularity of scale markers along the horizontal axis.

### Scale configuration

The `xScale` prop determines the interval between scale markers on the x-axis. By default, BarChart automatically calculates an appropriate scale interval based on the `minRange` and `maxRange` values. However, you can override this with a custom interval to achieve more granular or specific scale markings.

**When to use custom scale:**

- When you need specific scale intervals (e.g., increments of 250, 500, or 1000)
- When the automatic scale calculation doesn't provide the desired granularity
- When you want to match scale intervals across multiple charts for consistency
- When you need scale markers at specific values for better data interpretation

**How it works:**

The `xScale` value represents the interval between consecutive scale markers. For example:

- `xScale: 250` creates markers at 0, 250, 500, 750, 1000, etc.
- `xScale: 500` creates markers at 0, 500, 1000, 1500, 2000, etc.

The number of tick marks is automatically calculated as: `Math.ceil((maxRange - minRange) / xScale) + 1`

### Example

<Canvas of={BarChartStories.CustomScale} />

## Accessibility considerations

### Chart and row labeling

**Chart-level labeling:**

- Always provide either `title` or `aria-labelledby` to describe the chart (see Title and description section below for details)
- The chart is wrapped in a semantic `<figure>` element for proper structure

**Row-level labeling:**

- For non-interactive bars: A hidden text element (visible only to screen readers) is automatically added as the first child of each list item, summarizing the bar's values (e.g., "100 XP in Python")
- For interactive bars (with `onClick` or `href`): An `aria-label` is automatically generated from the bar's data and applied to the button or link element, ensuring proper screen reader announcements
- All accessibility labels are automatically generated from the bar's data - no manual `aria-label` props are required

## UX writing

- Keep y-axis labels concise (1-3 words)
- Use consistent unit labels (e.g., "XP", "hours", "points")
- Consider locale-aware number formatting for international audiences

### Title and description

The BarChart component uses semantic HTML to provide context and accessibility. The chart is wrapped in a [`<figure>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/figure) element, and the description is displayed in a [`<figcaption>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/figcaption) element. This semantic structure helps screen readers and other assistive technologies understand the relationship between the chart and its description. **Visual title + description is the greatly preferred pattern** for accessibility and user experience.

**Preferred pattern: Visual title + description**

Provide both `title` and `description` props to make the chart's purpose and key takeaways clear to all users:

- `title`: A heading that identifies the chart. Can be a string or an object with `{ as?: 'h1' | 'h2' | 'h3' | 'h4' | 'h5' | 'h6', title: string, variant?: Text['variant'] }` to specify the heading level and optionally override the default styling with a <LinkTo id="Typography/Text">Text variant</LinkTo>.
- `description`: A summary of the information or the overall takeaway displayed in the `<figcaption>` element.

<Canvas of={BarChartStories.WithVisualTitleAndDescription} />

**Alternative patterns:**
`hideTitle` and `hideDescription` will keep the screenreader text but hide the visual descriptions.

<Canvas of={BarChartStories.WithHiddenTitleAndDescription} />

- **External title with visual description**: Use `aria-labelledby` for the title but show the description visually when the title exists elsewhere but you want to display the description.

<Canvas of={BarChartStories.WithExternalTitle} />

**Best practices:**

- Always provide a `description` prop - it's required and should summarize the chart's key information
- Use semantic heading levels for titles (h1-h6) to maintain proper document structure
- When using `aria-labelledby`, ensure the referenced element exists and is properly labeled

## Playground

<Canvas sourceState="shown" of={BarChartStories.Default} />

<Controls />

## Internationalization

<Callout text="We are currently updating global internationalization in Gamut, so the following features are subject to change." />

BarChart supports internationalization through the `translations` prop, which allows you to customize all user-facing strings and configure locale-aware number formatting.

**Translation Structure:**

```typescript
type BarChartTranslations = {
  sortLabel: string;
  sortOptions: {
    none: string;
    labelAsc: string;
    labelDesc: string;
    valueAsc: string;
    valueDesc: string;
  };
  accessibility: {
    gainedNowAt: string; // Template: "{value} {unit} gained - now at {value} {unit} in {label}"
    inLabel: string; // Template: "{value} {unit} in {label}"
    inOnly: string; // Template: "{value} {unit} in "
  };
  locale: string; // For Intl.NumberFormat, e.g., 'en', 'es', 'fr', 'de-DE'
};
```

**Basic Usage:**

The `translations` prop is optional and accepts partial translations that will be merged with the default English translations. This means you only need to provide the translations you want to override.

```tsx
<BarChart
  title="Habilidades"
  barValues={barData}
  description="Progreso de habilidades"
  minRange={0}
  maxRange={200}
  sortFns={['alphabetically', 'none']}
  translations={{
    sortLabel: 'Ordenar por:',
    sortOptions: {
      none: 'Ninguno',
      labelAsc: 'Etiqueta (A-Z)',
      labelDesc: 'Etiqueta (Z-A)',
      valueAsc: 'Valor (Bajo-Alto)',
      valueDesc: 'Valor (Alto-Bajo)',
    },
    locale: 'es',
  }}
/>
```

**Partial Translations:**

You can provide only the translations you need to customize. All other strings will use the default English values:

```tsx
<BarChart
  // ... other props
  translations={{
    sortLabel: 'Sort by:',
    // sortOptions will use default English values
    locale: 'en-GB', // Use British English number formatting
  }}
/>
```

**Locale-Aware Number Formatting:**

The `locale` property controls how numbers are formatted throughout the chart using `Intl.NumberFormat`. This affects:

- Scale labels on the x-axis
- Value labels on bars
- All numeric displays

```tsx
// German locale (1.000 instead of 1,000)
<BarChart
  // ... other props
  translations={{
    locale: 'de-DE',
  }}
/>

// French locale
<BarChart
  // ... other props
  translations={{
    locale: 'fr-FR',
  }}
/>
```

**Accessibility Translations:**

The accessibility strings are used in automatically generated `aria-label` attributes for interactive bars and screen reader text for non-interactive bars. These should be translated to match the language of your application:

```tsx
<BarChart
  // ... other props
  translations={{
    accessibility: {
      gainedNowAt: 'ganado - ahora en', // Spanish: "gained - now at"
      inLabel: 'en', // Spanish: "in"
      inOnly: 'en ', // Spanish: "in "
    },
  }}
/>
```

**Best Practices:**

- Always provide complete translations for the language your application uses
- Use appropriate locale codes (e.g., `'en-US'`, `'es-ES'`, `'fr-FR'`) for number formatting
- Test accessibility strings with screen readers in the target language
- Consider creating translation objects that can be reused across multiple BarChart instances
