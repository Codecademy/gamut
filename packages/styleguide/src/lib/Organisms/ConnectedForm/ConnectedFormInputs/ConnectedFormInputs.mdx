import { Meta } from '@storybook/blocks';

import { ComponentHeader, LinkTo } from '~styleguide/blocks';

import * as ConnectedFormInputsStories from './ConnectedFormInputs.stories';
import { ConnectedFormInputsTable } from './ConnectedFormInputsTable';

export const parameters = {
  title: 'ConnectedFormInputs',
  subtitle: `Different form inputs for the ConnectedForm component.`,
  status: 'updating',
  source: {
    repo: 'gamut',
    githubLink:
      'https://github.com/Codecademy/gamut/blob/main/packages/gamut/src/ConnectedForm/ConnectedInputs/index.ts',
  },
};

<Meta of={ConnectedFormInputsStories} />

<ComponentHeader {...parameters} />

## Input types

We have a selection of `ConnectedInput` components that are visually identical to their un-connected <LinkTo id='Atoms/FormInputs'>FormInput</LinkTo> counterparts. Please reference the links below for component-specific prop and styling configuration:

<ConnectedFormInputsTable />

### ConnectedRadioGroupInput

`ConnectedRadioGroupInput` is an exception to the rule, and has some props that differ, particularly `options` â€” which takes an array of `ConnectedBaseRadioInputProps` components.

For further styling configurations, check out <LinkTo id="Atoms/FormInputs/Radio">RadioGroup</LinkTo>.

`ConnectedRadioGroup` and `ConnectedRadio` should rarely, if ever, be used outside of `ConnectedRadioGroupInput`.

### ConnectedNestedCheckboxes

`ConnectedNestedCheckboxes` is a component that allows you to create a nested checkbox group. It is a wrapper around the `ConnectedCheckbox` component and takes in an array `NestedCheckboxOption`s. Infinite levels of nesting are supported. Clicking a parent checkbox toggles all its children accordingly. Individual child checkboxes can be toggled independently. Checkbox states are `checked` if all children are checked, `indeterminate` if some children are checked, or `unchecked` if no children are checked. The values returned by the form on submit or update are an array of all selected values, including all children.

```tsx
<ConnectedFormGroup
  label="nested checkboxes field"
  name="nestedCheckboxesField"
  field={{
    component: ConnectedNestedCheckboxes,
    options: [
      {
        value: 'frontend',
        label: 'Frontend Technologies',
        children: [
          {
            value: 'react',
            label: 'React',
            options: [
              { value: 'nextjs', label: 'Next.js' },
              { value: 'typescript', label: 'TypeScript' },
            ],
          },
          {
            value: 'vue',
            label: 'Vue.js',
          },
          { value: 'angular', label: 'Angular' },
        ],
      },
      {
        value: 'backend',
        label: 'Backend Technologies',
        children: [
          { value: 'node', label: 'Node.js' },
          { value: 'python', label: 'Python' },
          { value: 'java', label: 'Java' },
        ],
      },
    ],
  }}
/>
```

## Usage

The components are engineered to be passed into the component prop of <LinkTo id="Organisms/ConnectedForm/ConnectedFormGroup">ConnectedFormGroup</LinkTo>, like so:

```tsx
<ConnectedFormGroup
  name="badRadioGroup"
  label="cool radio group dude"
  field={{
    component: ConnectedRadioGroupInput,
    // Type error, these options are not formatted correctly.
    options: ['one', 'two', 'zero'],
  }}
/>

<ConnectedFormGroup
  name="goodRadioGroup"
  label="cool radio group dude"
  field={{
    component: ConnectedRadioGroupInput,
    // Perfection ðŸ™Œ
    options: [
      { label: 'one', value: 'one' },
      { label: 'two', value: 'two' },
      { label: 'zero', value: 'zero' },
    ],
  }}
/>
```

Use outside of `ConnectedFormGroup` removes much of the accessibility and type-safety built into these components.

## Delaying updates to ConnectedForm

On forms with many nested and/or array-like fields, it can be useful for performance reasons to delay updating the form state until the user has finished updating a field (rather than, for example, on every keystroke in a text input).

To faciliate this, developers can use the `useDebouncedField` hook, which connects to `ConnectedForm` the same way that the `useField` hook or a `ConnectedInput` does internally, but delays the `setValue` call until the user has blurred focus on the input.

```tsx
// DebouncedInput.tsx
import { Input } from '@codecademy/gamut'

export const DebouncedInput: React.FC<...> = ({ name }) => {
  const { onChange, onBlur, value } = useDebouncedField({ name, type: 'text' })

  return (
    <Input
      name={name}
      type="text"
      onChange={onChange}
      onBlur={onBlur}
      value={value}
      htmlFor={name}
    />
  )
}

// FormPage.tsx
import { ConnectedForm } from '@codecademy/gamut'
import { DebouncedInput } from './DebouncedInput'

enum FieldNames {
  favoriteXFilesEpisode = 'favoriteXFilesEpisode'
}

export const FormPage: React.FC = () => {
  reutrn (
    <ConnectedForm
      defaultValues={{
        [FieldNames.favoriteXFilesEpisode]: 'Bad Blood'
      }}
      onSubmit={() => ...}
    >
      <DebouncedInput
        name={FieldNames.favoriteXFilesEpisode}
      />
    </ConnectedForm>
  )
}
```

`useDebouncedField` should not be used with any varaint of the standard `ConnectedInput`, as it will clash with the default `useField` instance used internally by those components.
