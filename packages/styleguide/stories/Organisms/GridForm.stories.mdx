import {
  Column,
  FormGroup,
  GridForm,
  Input,
  LayoutGrid,
  Markdown,
} from '@codecademy/gamut/src';
import { Background } from '@codecademy/gamut-styles';
import title from '@codecademy/macros/lib/title.macro';
import { PropsTable } from '@codecademy/storybook-addon-variance';
import { action } from '@storybook/addon-actions';
import { Canvas, Meta, Story } from '@storybook/addon-docs/blocks';
import { useState } from '@storybook/addons';

import { LinkTo } from '~styleguide/blocks';

import { FormLoadingExample } from './examples';

<Meta
  title={title}
  component={GridForm}
  parameters={{
    subtitle: `GridForm an efficient way to build and design forms on a grid.`,
    source: 'gamut',
    status: 'updating',
    design: {
      type: 'figma',
      url:
        'https://www.figma.com/file/ReGfRNillGABAj5SlITalN/%F0%9F%93%90-Gamut?node-id=1689%3A3910',
    },
  }}
/>

The GridForm organism provides an easy, out-of-the-box way to implement forms from a list of fields. When provided a list of fields, GridForm strings together the appropriate <LinkTo id="atoms-formelements-about--page">Form Elements</LinkTo> inside a <LinkTo id="layouts-layoutgrid--layout-grid">LayoutGrid</LinkTo>.

GridForm provides the following benefits:

1. **Simplicity**: This organism takes in plain JSON-like props and uses them to string together a validated form
2. **Accessibility**: All GridForms handle accessibility styling and behaviors, passing tests out-of-the-box
3. **Functionality**: Validation and submission logic is handled by the [react-hook-form](https://react-hook-form.com) library
4. **Visual Consistency**: Aligns all input elements with the correct vertical rhythms and grid spacing

<Canvas>
  <Story
    name="GridForm"
    args={{ validation: 'onSubmit', resetOnSubmit: true, target: '_parent' }}
  >
    {(args) => (
      <GridForm
        {...args}
        fields={[
          {
            label: 'Simple text',
            name: 'simple-text',
            size: 3,
            type: 'text',
          },
          {
            defaultValue: 'yeet',
            label: 'Text with default value',
            name: 'text-with-default',
            size: 4,
            type: 'text',
          },
          {
            label: 'Simple select',
            name: 'simple-select',
            options: ['', 'One fish', 'Two fish', 'Red fish', 'Blue fish'],
            size: 5,
            type: 'select',
            validation: {
              required: 'Please select an option',
              markdown: true,
            },
          },
          {
            label: 'Upload a cat image (we support pdf, jpeg, or png files)',
            name: 'file-input',
            size: 6,
            type: 'file',
            validation: {
              required: true,
              validate: (files) => {
                const { type } = files.item(0);
                const allowedTypes = [
                  'application/pdf',
                  'image/jpeg',
                  'image/png',
                ];
                if (!allowedTypes.includes(type))
                  return 'Please upload a pdf, jpeg, or png file.';
                return true;
              },
            },
          },
          {
            label: 'Write a paragraph about penguins',
            name: 'textarea-input',
            type: 'textarea',
            validation: {
              required: 'Please write something about penguins!',
            },
          },
          {
            label:
              "Validated, required text that must contain the word 'swag' twice",
            name: 'validated-required-text',
            size: 5,
            type: 'text',
            validation: {
              required: true,
              pattern: {
                value: /swag(.*)swag/,
                message: 'Not enough swag',
              },
            },
          },
          {
            description: 'I have swag',
            label: 'Swag levels',
            name: 'enough-swag',
            size: 3,
            type: 'checkbox',
            id: 'my-super-cool-id',
            defaultValue: true,
          },
          {
            label: 'Preferred Modern Artist',
            name: 'artist',
            options: [
              {
                label: 'Cardi B',
                value: 'cardi',
              },
              {
                label: 'Nicki Minaj',
                value: 'nicki',
              },
            ],
            size: 4,
            type: 'radio-group',
            validation: {
              required: 'You gotta pick one!',
            },
          },
          {
            label: 'End User License Agreement',
            description:
              'I accept the terms and conditions (required or else!!!)',
            name: 'eula-checkbox-required',
            type: 'checkbox',
            validation: {
              required: 'Please check the box to agree to the terms.',
            },
          },
        ]}
        onSubmit={async (values) => {
          action('Form Submitted')(values);
        }}
        submit={{
          contents: 'Submit Me!?',
        }}
      />
    )}
  </Story>
</Canvas>

<PropsTable of={GridForm} />

## Modifying Elements

`GridForms` are laid out with `LayoutGrid`, so you can override its `columnGap` and `rowGap` with the normal string or responsive layouts to style and align the GridForm to your designs. You can also configure the `GridFormButtons` to modify the submit buttons and optional cancel buttons.

**You should build something outside of GridForm if you need...**

- **Multi-step forms**: GridForm is best used for single page operations with a discrete submit action
- **Custom behaviors for messaging or validation states**: form validation is already built into each input element, so any custom messaging is best done outside the component

## Designing with GridForm

All [Form Input](https://www.figma.com/file/ReGfRNillGABAj5SlITalN/%F0%9F%93%90-Gamut?node-id=1189%3A0) components in the Figma library are consistent with their implementations in code. By setting the form inputs within the component's layout grid, we can design forms that are compatible with Gamut.

The [GridForm page in Gamut](https://www.figma.com/file/ReGfRNillGABAj5SlITalN/%F0%9F%93%90-Gamut?node-id=1689%3A3910) also contains several starter templates for incorporating this organism in your designs.

- **Starter**: Contains sample components to begin creating your own form
- **Sections**: Contains the headers and dividers that are rendered in the optional <LinkTo id="organisms-gridform--sections">Sections</LinkTo> modules
- **Inline Submit**: A form incorporating the <LinkTo id="organisms-gridform--inline-text-input-with-label">Inline Submit</LinkTo> Button style of GridForm
- **Instructions**: Contains suggestions for modifying the Figma component for your own designs

### Figma Component Instructions

- Enable Layout Grid (^G)
- Select a `‚ùñ GridForm` variant as a template
  - Starter, Sections, Inline Submit
- Detatch the component to modify the `üìê LayoutGrid`
- Add, remove, and edit `‚¨¶ Form Inputs`
  - Input Field, TextArea, Checkbox, Radio Button, Select
- Customize `üö• GridFormButtons`
  - Submit button style (Fill/CTA), position, cancel button

## Disabled Inputs

If an input is not meant to be usable, such as when a portion of a form is disabled pending user action, you can make it visually disabled with a `disabled` field member.

<Canvas>
  <Story name="Disabled Inputs">
    {() => (
      <GridForm
        hideRequiredText
        fields={[
          {
            disabled: true,
            label: 'Disabled text',
            name: 'disabled-text',
            size: 6,
            type: 'text',
          },
          {
            label: 'Enabled text',
            name: 'enabled-text',
            size: 6,
            type: 'text',
          },
        ]}
        onSubmit={async (values) => {
          action('Form Submitted')(values);
        }}
        submit={{
          contents: 'Right Submit!?',
          position: 'right',
        }}
      />
    )}
  </Story>
</Canvas>

## GridForm-atting

We can use the `size` and `rowspan` props (borrowed from <LinkTo id="layouts-layoutgrid--layout-grid">LayoutGrid</LinkTo>) to customize the layouts of our GridForms. You can also customize the `FormRequiredText` using the `requiredTextProps`. `FormRequiredText` should be spaced apart from or be stylistically different from the text element above it.

<Canvas>
  <Story name="Rowspan Formatting">
    {() => (
      <GridForm
        requiredTextProps={{ color: 'danger', variant: 'title-xs' }}
        fields={[
          {
            label: 'Fave Gamut Component',
            name: 'rowspan-radiogroup',
            options: [
              {
                label: 'FlexBox',
                value: 'flex',
              },
              {
                label: 'GridForm',
                value: 'grid',
              },
              {
                label: 'Text',
                value: 'text',
              },
            ],
            size: 3,
            rowspan: 3,
            type: 'radio-group',
            validation: {
              required: 'You gotta pick one!',
            },
          },
          {
            label: 'Simple text',
            name: 'rowspan-simple-text',
            size: 3,
            type: 'text',
          },
          {
            defaultValue: 'yeet',
            label: 'Text with default value',
            name: 'text-with-default-formatting',
            size: 4,
            type: 'text',
          },
          {
            label: 'Simple select (required)',
            name: 'simple-select-formatting',
            options: ['', 'One fish', 'Two fish', 'Red fish', 'Blue fish'],
            size: 5,
            type: 'select',
            validation: {
              required: 'Please select an option',
            },
          },
        ]}
        onSubmit={async (values) => {
          action('Form Submitted')(values);
        }}
        submit={{
          contents: 'Submit',
        }}
      />
    )}
  </Story>
</Canvas>

## Submit Button Position

We can position the submit button by passing the position prop with a
value of left, center, right, or stretch.

<Canvas>
  <Story name="Submit Button Position">
    {() => (
      <LayoutGrid>
        <Column size={6}>
          <GridForm
            hideRequiredText
            fields={[
              {
                label: 'Simple text',
                name: 'right-sub-simple-text',
                type: 'text',
              },
            ]}
            onSubmit={async (values) => {
              action('Form Submitted')(values);
            }}
            submit={{
              contents: 'Right Submit!?',
              position: 'right',
            }}
          />
        </Column>
        <Column size={6}>
          <GridForm
            hideRequiredText
            fields={[
              {
                label: 'Simple text',
                name: 'center-sub-simple-text',
                type: 'text',
              },
            ]}
            onSubmit={async (values) => {
              action('Form Submitted')(values);
            }}
            submit={{
              contents: 'Center Submit!?',
              position: 'center',
            }}
          />
        </Column>
        <Column size={6}>
          <GridForm
            hideRequiredText
            fields={[
              {
                label: 'Simple text',
                name: 'left-sub-simple-text',
                type: 'text',
              },
            ]}
            onSubmit={async (values) => {
              action('Form Submitted')(values);
            }}
            submit={{
              contents: 'Left Submit!?',
              position: 'left',
            }}
          />
        </Column>
        <Column size={6}>
          <GridForm
            hideRequiredText
            fields={[
              {
                label: 'Simple text',
                name: 'stretch-sub-simple-text',
                type: 'text',
              },
            ]}
            onSubmit={async (values) => {
              action('Form Submitted')(values);
            }}
            submit={{
              contents: 'Stretch Submit!?',
              position: 'stretch',
            }}
          />
        </Column>
      </LayoutGrid>
    )}
  </Story>
</Canvas>

## Submit Button Options

We can specify the version of our button by passing the type prop. We can choose between
the <LinkTo id="atoms-button--fill-button">`FillButton`</LinkTo> or <LinkTo id="atoms-button--cta-button">`CTAButton`</LinkTo>.

<Canvas>
  <Story name="Submit Button Options">
    {() => (
      <>
        <GridForm
          hideRequiredText
          fields={[
            {
              label: 'Simple text',
              name: 'fill-button-simple-text',
              size: 6,
              type: 'text',
            },
          ]}
          onSubmit={async (values) => {
            action('Form Submitted')(values);
          }}
          submit={{
            contents: 'Fill Button',
            size: 6,
          }}
        />
        <GridForm
          hideRequiredText
          fields={[
            {
              label: 'Simple text',
              name: 'cta-button-simple-text',
              size: 6,
              type: 'text',
            },
          ]}
          onSubmit={async (values) => {
            action('Form Submitted')(values);
          }}
          submit={{
            type: 'cta',
            contents: 'CTA Button',
            size: 12,
          }}
        />
        <GridForm
          hideRequiredText
          fields={[
            {
              label: 'Simple text',
              name: 'fill-dark-mode-simple-text',
              size: 6,
              type: 'text',
            },
          ]}
          onSubmit={async (values) => {
            action('Form Submitted')(values);
          }}
          submit={{
            contents: 'Fill Button Dark Mode',
            size: 12,
            mode: 'dark',
          }}
        />
        <GridForm
          hideRequiredText
          fields={[
            {
              label: 'Simple text',
              name: 'cta-dark-mode-simple-text',
              size: 6,
              type: 'text',
            },
          ]}
          onSubmit={async (values) => {
            action('Form Submitted')(values);
          }}
          submit={{
            type: 'cta',
            contents: 'CTA Button Dark Mode',
            size: 12,
            mode: 'dark',
          }}
        />
      </>
    )}
  </Story>
</Canvas>

## Inline Submit Button

We can make the Submit button inline with an input by setting the column
sizes so they fit on the same row (e.g size 8 for an input and size 4 for
the submit).

We can additionally remove the label from text inputs and checkbox inputs.
Use the `hideLabel` prop to remove the label, allowing the submit button to
align nicely with the input.

#### Submit button aligned correctly with a hidden label

<Canvas>
  <Story name="Inline Text Input With Label">
    {() => (
      <GridForm
        hideRequiredText
        fields={[
          {
            hideLabel: true,
            label: 'Label',
            name: 'email',
            size: 8,
            type: 'text',
          },
        ]}
        onSubmit={async (values) => {
          action('Form Submitted')(values);
        }}
        submit={{
          contents: 'Inline Submit!?',
          size: 4,
          position: 'right',
        }}
      />
    )}
  </Story>
</Canvas>

## Cancel button

Optionally, include a cancel button.

<Canvas>
  <Story name="Cancel button">
    <LayoutGrid>
      <Column size={6}>
        <GridForm
          hideRequiredText
          fields={[
            {
              label: 'Simple text',
              name: 'right-sub-simple-text',
              type: 'text',
            },
          ]}
          onSubmit={async (values) => {
            action('Form Submitted')(values);
          }}
          cancel={{
            children: 'Cancel',
            onClick: () => {},
          }}
          submit={{
            contents: 'Right Submit!?',
            position: 'right',
          }}
        />
      </Column>
      <Column size={6}>
        <GridForm
          hideRequiredText
          fields={[
            {
              label: 'Simple text',
              name: 'center-sub-simple-text',
              type: 'text',
            },
          ]}
          onSubmit={async (values) => {
            action('Form Submitted')(values);
          }}
          cancel={{
            children: 'Cancel',
            onClick: () => {},
          }}
          submit={{
            contents: 'Center Submit!?',
            position: 'center',
          }}
        />
      </Column>
      <Column size={6}>
        <GridForm
          hideRequiredText
          fields={[
            {
              label: 'Simple text',
              name: 'left-sub-simple-text',
              type: 'text',
            },
          ]}
          onSubmit={async (values) => {
            action('Form Submitted')(values);
          }}
          cancel={{
            children: 'Cancel',
            onClick: () => {},
          }}
          submit={{
            contents: 'Left Submit!?',
            position: 'left',
          }}
        />
      </Column>
      <Column size={6}>
        <GridForm
          hideRequiredText
          fields={[
            {
              label: 'Simple text',
              name: 'stretch-sub-simple-text',
              type: 'text',
            },
          ]}
          onSubmit={async (values) => {
            action('Form Submitted')(values);
          }}
          cancel={{
            children: 'Cancel',
            onClick: () => {},
          }}
          submit={{
            contents: 'Stretch Submit!?',
            position: 'stretch',
          }}
        />
      </Column>
    </LayoutGrid>
  </Story>
</Canvas>

## Custom inputs

Some forms, such as the checkout flows that use Recurly, need to define
their own inputs. We can specify a 'custom' field type to with a [render prop](https://reactjs.org/docs/render-props.html).

We also have a 'custom-group' type for when you are passing in a custom FormGroup - including a label. If you do not want GridForm to surface errors for your field, you should likely use a 'custom-group'. If you chose to go this route, please be aware of [accessibility best practices](https://www.deque.com/blog/anatomy-of-accessible-forms-best-practices/) for forms.

<Canvas>
  <Story name="Custom Inputs">
    {() => (
      <GridForm
        fields={[
          {
            render: ({ error, setValue }) => (
              <>
                <Input
                  error={!!error}
                  id="custom-text-input"
                  type="text"
                  onChange={(event) => setValue(event.target.value)}
                />
                üï∫
              </>
            ),
            label: 'Gimme two more swags',
            name: 'custom-input',
            validation: {
              required: true,
              pattern: {
                value: /swag(.*)swag/,
                message: 'Still not enough swag, what are you doing... üí¢',
              },
            },
            type: 'custom',
          },
          {
            render: ({ error, setValue }) => (
              <FormGroup label="updog" width="100%">
                <Input
                  error={!!error}
                  id="custom-text-group-input"
                  type="text"
                  onChange={(event) => setValue(event.target.value)}
                />
              </FormGroup>
            ),
            label: 'Gimme two more swags',
            name: 'custom-input-group',
            validation: {
              required: true,
              pattern: {
                value: /swag(.*)swag/,
                message: 'Still not enough swag, what are you doing... üí¢',
              },
            },
            type: 'custom-group',
          },
        ]}
        onSubmit={async (values) => {
          action('Form Submitted')(values);
        }}
        submit={{
          contents: 'Submit Me!?',
        }}
      />
    )}
  </Story>
</Canvas>

## Placeholder Text

Text inputs are allowed to have traditional `placeholder` text.
This is a somewhat dangerous behavior for accessibility, as browsers
generally don't render placeholder text with high enough color contrast
for AA standards. If you do need to use placeholder text, such as on
landing page forms that have been shown to have higher completion rates
with the text, please make sure the placeholder text doesn't add any new
information to the form -- it should really only rephrase the text label.

See [this article](https://www.nngroup.com/articles/form-design-placeholders/) or
more details on why using placeholders is often bad.

<Canvas>
  <Story name="Placeholder Text">
    {() => (
      <GridForm
        hideRequiredText
        fields={[
          {
            label: 'Email',
            placeholder: 'Your email',
            name: 'placeholder',
            type: 'email',
          },
        ]}
        onSubmit={async (values) => {
          action('Form Submitted')(values);
        }}
        submit={{
          contents: 'Submit Me!?',
        }}
      />
    )}
  </Story>
</Canvas>

## On Field Update

A field can take an onUpdate callback. This callback will fire when the
field's value changes. This could be useful if you need to use the
field's value in a parent component before onSubmit gets triggered.

<Canvas>
  <Story name="On Field Update">
    {() => {
      const [text, setText] = useState('');
      return (
        <>
          <>The text value is: {text}</>
          <GridForm
            hideRequiredText
            fields={[
              {
                label: 'Text with onUpdate',
                name: 'onUpdate-simple-text',
                size: 3,
                type: 'text',
                onUpdate: setText,
              },
            ]}
            onSubmit={async (values) => {
              action('Form Submitted')(values);
            }}
            submit={{
              contents: 'Submit Me!?',
            }}
          />
        </>
      );
    }}
  </Story>
</Canvas>

## With InfoTip

A field can include our existing `InfoTip`. The position of the infotip on each field is always set to the bottom-right.

See the <LinkTo id="atoms-forminputs-radio--radio">`Radio`</LinkTo> story for an example of how to add a infotip to a radio option.

<Canvas>
  <Story name="InfoTip">
    {() => (
      <>
        <GridForm
          my={16}
          fields={[
            {
              infotip: {
                info:
                  'Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.',
                alignment: 'bottom-left',
              },
              label: 'Tool input',
              name: 'input-field',
              size: 6,
              type: 'text',
            },
            {
              infotip: {
                info: (
                  <Markdown text="My grandmother used to tell me stories..." />
                ),
                alignment: 'bottom-right',
              },
              label: 'Select with infotip',
              options: ['', 'Water', 'Earth', 'Fire', 'Air', 'Boomerang'],
              size: 3,
              type: 'select',
              validation: {
                required: 'Please select an option',
              },
              name: 'select-field',
            },
            {
              infotip: {
                info:
                  'Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.',
              },
              label: 'Write a paragraph about infotips',
              name: 'textarea-field',
              size: 6,
              type: 'textarea',
              rows: 6,
              placeholder: 'Check out my infotip',
              validation: {
                required: 'Please write something about infotips!',
              },
            },
            {
              infotip: {
                info:
                  'Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.',
              },
              label: 'Preferred Modern Artist',
              name: 'modern-artist',
              options: [
                {
                  label: 'Taylor Swift',
                  value: 'taylor-swift',
                },
                {
                  label: 'Beyonce',
                  value: 'beyonce',
                },
              ],
              size: 3,
              type: 'radio-group',
              validation: {
                required: 'You gotta pick one!',
              },
            },
            {
              infotip: {
                info:
                  'Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.',
                alignment: 'bottom-right',
              },
              label: 'End User License Agreement',
              description: 'I promise that I read it',
              name: 'eula-checkbox-required-agreement',
              size: 4,
              type: 'checkbox',
              validation: {
                required: 'Please check the box to agree to the terms.',
              },
            },
          ]}
          onSubmit={async (values) => {
            action('Form Submitted')(values);
          }}
          submit={{
            contents: 'Submit',
            size: 12,
            theme: 'hyper',
          }}
        />
      </>
    )}
  </Story>
</Canvas>

## Sections

Our `GridForm`s optionally take an array of sections that have left and center-aligned variants.

Each sections should have a title that correctly follows [heading ranks](https://usability.yale.edu/web-accessibility/articles/headings). You can set the text type of this title though the `as` prop on that section -- the default is `h2`. You can only set the `as` prop to a heading.

You can set the <LinkTo id="typography-text--variants">Text variant</LinkTo> prop for the section title the same way. Only title variants are reccomended, but if you need more granular control of the Text component, you can pass them into `titleWrapperProps`.

When using the left-aligned layout, please note that the `title` takes up 3 columns, so any field size over 9 may cause inconsistent behavior!

<Canvas>
  <Story name="Sections">
    {() => {
      return (
        <GridForm
          requiredTextProps={{ color: 'primary', fontStyle: 'italic' }}
          fields={[
            {
              title: 'first section',
              layout: 'left',
              variant: 'title-xs',
              titleWrapperProps: {
                color: 'danger',
              },
              fields: [
                {
                  label: 'hi?',
                  name: 'text01-left-section',
                  size: 4,
                  type: 'text',
                  validation: {
                    required: true,
                  },
                },
                {
                  label: 'hello?',
                  name: 'text02-left-section',
                  size: 4,
                  type: 'text',
                  validation: {
                    required: true,
                  },
                },
                {
                  label: 'Write a paragraph.',
                  name: 'paragraph01-left-section',
                  size: 8,
                  type: 'textarea',
                  validation: {
                    required: 'Please write something about penguins!',
                  },
                },
                {
                  label: 'howdy?',
                  name: 'text03-left-section',
                  size: 4,
                  type: 'text',
                  validation: {
                    required: true,
                  },
                },
                {
                  label: 'whats up?',
                  name: 'text04--left-section',
                  size: 4,
                  type: 'text',
                  validation: {
                    required: true,
                  },
                },
                {
                  label: 'Write another long paragraph',
                  name: 'paragraph02-left-section',
                  size: 8,
                  type: 'textarea',
                  validation: {
                    required: 'Please write something about penguins!',
                  },
                },
              ],
            },
            {
              title: 'hi there... again',
              as: 'h3',
              fields: [
                {
                  label: 'hello....',
                  name: 'text01-center-section',
                  size: 5,
                  type: 'text',
                  validation: {
                    required: true,
                  },
                },
              ],
            },
          ]}
          sectionGap={48}
          onSubmit={async (values) => {
            action('Form Submitted')(values);
          }}
          submit={{
            contents: 'Submit me',
            size: 12,
          }}
          validation="onSubmit"
        />
      );
    }}
  </Story>
</Canvas>

## Custom Error

A field can take a custom error in addition to validation errors. The validation error will always take precedence to the custom error.

<Canvas>
  <Story name="Custom Error">
    {() => {
      return (
        <GridForm
          fields={[
            {
              label: 'Who is the best at bending?',
              name: 'custom-error',
              size: 5,
              type: 'text',
              customError: 'NOT Flexo.',
              validation: {
                required: true,
                pattern: {
                  value: /Bender/,
                  message: 'Just type Bender...',
                },
              },
            },
          ]}
          onSubmit={async (values) => {
            action('Form Submitted')(values);
          }}
          submit={{
            contents: 'Submit Me!?',
            size: 12,
          }}
        />
      );
    }}
  </Story>
</Canvas>

## Hidden Input

Hidden inputs can be used to include data that users can't see or modify with the submission. For this implementation you can set the `defaultValue` in the object and it will be submitted with the regular form data.

<Canvas>
  <Story name="Hidden Input">
    {() => (
      <GridForm
        fields={[
          {
            type: 'hidden',
            name: 'secret-stuff',
            defaultValue: "I'm invisible!",
          },
          {
            label: "There's more than one field here!",
            name: 'custom-hidden-input',
            type: 'email',
          },
        ]}
        onSubmit={async (values) => {
          action('Form Submitted')(values);
        }}
        submit={{
          contents: 'Submit',
        }}
      />
    )}
  </Story>
</Canvas>

## Sweet Container Input

"Sweet container" ([honeypot](<https://en.wikipedia.org/wiki/Honeypot_(computing)>)) inputs can be used to detect bots by providing a field that would not generally be clicked by human users, but might be triggered automatically by bots.

We call it a "sweet container" so that bots do not immediately detect it as a honeypot input.

<Canvas>
  <Story name="Sweet Container Input">
    {() => (
      <GridForm
        hideRequiredText
        fields={[
          {
            label: 'This is our sticky sweet label',
            name: 'sweet-container',
            type: 'sweet-container',
          },
          {
            label: "There's something sticky and sweet here!",
            name: 'custom-input',
            type: 'email',
          },
        ]}
        onSubmit={async (values) => {
          action('Form Submitted')(values);
        }}
        submit={{
          contents: 'Submit',
        }}
      />
    )}
  </Story>
</Canvas>

## Markdown Errors

GridForm renders errors through our <LinkTo id="atoms-markdown--basics">Markdown</LinkTo> component so we can optionally add markdown to our validation messages.

<Canvas>
  <Story name="Markdown Errors">
    {() => (
      <GridForm
        fields={[
          {
            label: 'there is a markdown error here!',
            name: 'markdown-error',
            type: 'email',
            validation: {
              required:
                'This is [an example](https://www.youtube.com/watch?v=5IuRzJRrRpQ) error link.',
            },
          },
        ]}
        onSubmit={async (values) => {
          action('Form Submitted')(values);
        }}
        submit={{
          contents: 'Submit',
        }}
      />
    )}
  </Story>
</Canvas>

## `<ColorMode />`

Here's an example using components in context. By toggling dark mode you can see all the colors map to a new color that is accessible for the mode by default. Please use the ColorMode control on the top of this page to check it out!

Please note you **cannot** use the deprecated 'business' button type with `ColorMode`.

## Checkbox Spacing

If you need to checkboxes to fit into a smaller space, you can use our our `tight` spacing prop for checkboxes that are a bit closer together.

<Canvas>
  <Story name="Checkbox Spacing">
    {() => (
      <GridForm
        rowGap={0}
        fields={[
          {
            description: 'i am cozy',
            name: 'cozy-check-0',
            size: 6,
            type: 'checkbox',
            id: 'cozy-check-0',
            defaultValue: true,
            spacing: 'tight',
            label: 'must check',
            validation: {
              required: 'sos',
            },
          },
          {
            description: 'i am also cozy',
            name: 'cozy-check-1',
            size: 6,
            type: 'checkbox',
            id: 'cozy-check-1',
            defaultValue: true,
            spacing: 'tight',
            label: 'must check',
            validation: {
              required: 'pls help',
            },
          },
          {
            description: 'i am cozy as well',
            name: 'cozy-check-2',
            size: 6,
            type: 'checkbox',
            id: 'cozy-check-2',
            defaultValue: true,
            label: 'you do not have to check this',
            spacing: 'tight',
          },
          {
            description: 'i am cozy too',
            name: 'cozy-check-3',
            size: 6,
            type: 'checkbox',
            id: 'cozy-check-3',
            defaultValue: true,
            label: 'you do not have to check this',
            spacing: 'tight',
          },
        ]}
        onSubmit={async (values) => {
          action('Form Submitted')(values);
        }}
        submit={{
          contents: 'Submit',
          position: 'right',
        }}
      />
    )}
  </Story>
</Canvas>

## Loading

<Canvas>
  <Story name="Loading States">
    {() => (
      <>
        <Background bg="beige" p={32}>
          <GridForm
            hideRequiredText
            fields={[
              {
                label: 'Email',
                placeholder: 'Your email',
                name: 'loading-beige',
                type: 'email',
              },
            ]}
            onSubmit={async (values) => {
              action('Form Submitted')(values);
            }}
            submit={{
              loading: true,
              contents: 'Submit Me!?',
            }}
          />
        </Background>
        <Background bg="navy" p={32}>
          <GridForm
            hideRequiredText
            fields={[
              {
                label: 'Email',
                placeholder: 'Your email',
                name: 'loading-navy',
                type: 'email',
              },
            ]}
            onSubmit={async (values) => {
              action('Form Submitted')(values);
            }}
            submit={{
              disabled: true,
              contents: 'Submit Me!?',
            }}
          />
        </Background>
      </>
    )}
  </Story>
</Canvas>

## Disabled Fields on Submit

`disableFieldsOnSubmit` will disable all form fields once the form has been successfully submitted. If you have any server-side validation that needs to happen, we recommend using the `wasSubmitSuccessful` prop, but submission will also fail if a promise is rejected within your `onSubmit` or if a field does not pass validation.

<Canvas>
  <Story name="Disabled Fields on Submit">
    {() => (
      <>
        <Background bg="palePink" p={32}>
          <GridForm
            hideRequiredText
            disableFieldsOnSubmit
            fields={[
              {
                label: 'Email',
                placeholder: 'i will disable on correct submission!',
                name: 'disabled-fields-on-submit',
                type: 'email',
                validation: {
                  required: 'pls fill this out',
                  pattern: {
                    value: /^\w+([.-]?\w+)*@\w+([.-]?\w+)*(\.\w{2,})+$/,
                    message: 'that is not an email üòî',
                  },
                },
              },
            ]}
            onSubmit={async (values) => {
              action('Form Submitted')(values);
            }}
            submit={{
              contents: 'Submit Me üíñ',
            }}
          />
        </Background>
        <Background bg="black" p={32}>
          <GridForm
            hideRequiredText
            disableFieldsOnSubmit
            wasSubmitSuccessful={false}
            fields={[
              {
                label: 'Email',
                placeholder: 'i will NEVER disable.',
                name: 'disabled-fields-on-submit-ii',
                type: 'email',
                validation: {
                  required: 'pls fill this out',
                },
              },
            ]}
            onSubmit={async (values) => {
              action('Form Submitted')(values);
            }}
            submit={{
              contents: 'Submit Me üòà',
            }}
          />
        </Background>
        <Background bg="paleBlue" p={32}>
          <GridForm
            hideRequiredText
            disableFieldsOnSubmit
            fields={[
              {
                label: 'Email',
                placeholder: 'i will also never disable...',
                name: 'disabled-fields-on-submit-iii',
                type: 'email',
                validation: {
                  required: 'pls fill this out',
                  validate: {
                    checkValue: () =>
                      false || "It's never gonna work out between us",
                  },
                },
              },
            ]}
            onSubmit={async (values) => {
              action('Form Submitted')(values);
            }}
            submit={{
              contents: 'Submit Me ü§∑üèª',
            }}
          />
        </Background>
      </>
    )}
  </Story>
</Canvas>

## Reset Form on Submit

`resetOnSubmit` will reset the form once the GridForm has been successfully submitted. If you have any server validation that needs to happen, we recommend using the `wasSubmitSuccessful` prop, but submission will also fail if a promise is rejected within your `onSubmit` or if a field does not pass validation.

<Canvas>
  <Story name="Reset Form on Submit">
    {() => (
      <>
        <Background bg="beige" p={32}>
          <GridForm
            hideRequiredText
            resetOnSubmit
            fields={[
              {
                label: 'Email',
                placeholder: 'i will reset on correct submission!',
                name: 'reset-on-submit',
                type: 'email',
                validation: {
                  required: 'pls fill this out',
                  pattern: {
                    value: /^\w+([.-]?\w+)*@\w+([.-]?\w+)*(\.\w{2,})+$/,
                    message: 'that is not an email üòî',
                  },
                },
                size: 12,
              },
            ]}
            onSubmit={async (values) => {
              action('Form Submitted')(values);
            }}
            submit={{
              contents: 'Submit Me üíñ',
            }}
          />
        </Background>
      </>
    )}
  </Story>
</Canvas>

We can combine these together to create some pretty cool forms which have a loading state, disable their fields while submitting, and reset the form when the submit was successful.

<FormLoadingExample />

## hideRequiredText

`hideRequiredText` will hide the '\* Required' text that appears at the top of our forms. This should only be hidden if the form has no required fields.

<Canvas>
  <Story name="hideRequiredText">
    {() => (
      <>
        <Background bg="paleBlue" p={32}>
          <GridForm
            hideRequiredText
            fields={[
              {
                label: 'A field',
                placeholder: 'I am very optional',
                name: 'very-optional',
                type: 'input',
                size: 12,
              },
              {
                label: 'A field',
                placeholder: 'I am very optional',
                name: 'very-optional',
                type: 'input',
                size: 12,
              },
            ]}
            onSubmit={async (values) => {
              action('Form Submitted')(values);
            }}
            submit={{
              contents: 'Submit Me üíñ',
            }}
          />
        </Background>
      </>
    )}
  </Story>
</Canvas>

## Solo Field Forms

Solo field form should always have their solo input be required. They should automagically not have the required/optional text - if you have a custom rendered hidden input, you may have to use the `hasSoloField` prop.

<Canvas>
  <Story name="Solo Field Form">
    {() => (
      <>
        <Background bg="paleBlue" p={32}>
          <GridForm
            fields={[
              {
                label: 'A field',
                placeholder: 'I am a required solo field',
                name: 'so-required',
                type: 'input',
                size: 12,
                validation: {
                  required: 'I am required',
                },
              },
            ]}
            onSubmit={async (values) => {
              action('Form Submitted')(values);
            }}
            submit={{
              contents: 'Submit Me üíñ',
            }}
          />
        </Background>
      </>
    )}
  </Story>
</Canvas>
